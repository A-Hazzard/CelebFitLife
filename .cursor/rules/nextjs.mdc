---
description: 
globs: 
alwaysApply: false
---
# Senior Software Engineering Rules for Ourlime Web Project

This project follows strict engineering guidelines to ensure code quality, maintainability, and security.  
All contributors must adhere to the following rules, which are enforced throughout the codebase.

---

## 1. Package Management & Build Integrity

- **Use `pnpm` exclusively** for all package management tasks (install, update, remove).
- After any code or dependency change, always run `pnpm build`.
- If a build error occurs, fix the error, then re-run `pnpm build`.
- Repeat this process recursively until the project builds cleanly with zero errors or warnings.
- For development, use `pnpm dev` to start the local development server.

**Reference:**  
- [package.json](mdc:package.json)

---

## 2. TypeScript Discipline & Types Organization

- **All type definitions must reside in the appropriate types directories:**
  - Application-wide types should be in [`types/`](mdc:types)
  - Component or library-specific types should be in [`lib/types/`](mdc:lib/types)
  - Do not define types or interfaces directly in component, helper, or utility files.
- **Prefer `type` over `interface`** for consistency across the codebase.
- **No `any` allowed** - Create appropriate type definitions for all variables and functions.
- Always import types from their respective type files - avoid redefining types.
- Ensure type exports are properly named and documented.

**References:**  
- [types/](mdc:types)
- [lib/types/](mdc:lib/types)

---

## 3. ESLint & Code Style

- **Never ignore ESLint rule violations.**
- Address all ESLint warnings and errors immediately.
- Run `pnpm lint` regularly to catch and fix style issues.
- Use the project's Prettier configuration for consistent formatting by running `pnpm format`.
- Follow the established code style in the existing files for consistency.

**Reference:**  
- [.eslintrc.json](mdc:.eslintrc.json)
- [.prettierrc](mdc:.prettierrc)

---

## 4. File Organization & Separation of Concerns

- **Keep all `page.tsx` and component files lean.**
  - Offload complex logic into helper functions and utilities.
- **API-related logic should reside in [`lib/helpers/`](mdc:lib/helpers) or specific feature directories.**
- **Shared utilities should reside in [`lib/utils/`](mdc:lib/utils) or [`utils/`](mdc:utils).**
- **Context providers should be in [`lib/contexts/`](mdc:lib/contexts) or [`context/`](mdc:context).**
- Organize feature-specific code within their related directories in `lib/` (e.g., `lib/chat/`, `lib/profile/`).
- Do not mix API logic with UI or utility logic.

**References:**  
- [lib/helpers/](mdc:lib/helpers)
- [lib/utils/](mdc:lib/utils)
- [components/](mdc:components)
- [app/](mdc:app)

---

## 5. Comments & Documentation

- **Remove redundant comments** that simply restate the meaning of well-named code.
- In helper and utility files:
  - Every function should have a concise block comment describing:
    - Its purpose
    - Its parameters
    - Its return value
- Document complex business logic with clear explanations.
- Update comments when code changes.

---

## 6. Security & Authentication/Authorization

- **Implement secure authentication practices** through Firebase Authentication.
- **Follow OWASP standards** to safeguard code from vulnerabilities.
- Never expose sensitive information (API keys, tokens) in client-side code.
- Always validate and sanitize user input, especially in form submissions.
- Use middleware for route protection where necessary.

**References:**  
- [middleware.ts](mdc:middleware.ts)
- [lib/firebaseConfig.ts](mdc:lib/firebaseConfig.ts)

---

## 7. Component Structure & State Management

- Use appropriate state management solutions based on scope:
  - React's `useState` and `useReducer` for local component state
  - Context API for shared state across component tree
  - Zustand for application-wide state management
- Keep components focused on a single responsibility.
- Extract reusable UI elements into separate components.
- Implement proper error handling in components, especially for async operations.

---

## 8. Performance Optimization

- Implement proper code-splitting and lazy loading for pages and large components.
- Optimize images using Next.js Image component.
- Minimize unnecessary re-renders with memoization techniques.
- Use efficient data fetching patterns to prevent waterfalls.
- Implement proper caching strategies for API responses.

---

## 9. Testing Best Practices

- Write Cypress tests for critical user flows.
- Run tests before pushing code to the repository.
- Use `pnpm test` or `pnpm test:open` for running Cypress tests.
- Ensure tests are deterministic and not flaky.

**Reference:**  
- [cypress/](mdc:cypress)
- [cypress.config.ts](mdc:cypress.config.ts)

---

## 10. Accessibility & Internationalization

- Ensure all components are accessible with proper ARIA attributes.
- Use semantic HTML elements.
- Support keyboard navigation.
- Prepare for internationalization by avoiding hardcoded strings where possible.

---

**Summary:**  
Persistence: Keep going until the job is completely solved before ending your turn.
Plan than reflect: Plan thoroughly before every tool call then reflect on the outcome after
This project enforces strict discipline in type safety, code style, modularity, security, and build integrity.  
Use your tools don't guess: If you're unsure about code or files, open them - do not hallucinate.
All contributors must follow these rules to ensure a robust, maintainable, and secure codebase.