---
description: 
globs: 
alwaysApply: true
---
# Senior Software Engineering Rules for Next.js Projects

This document provides strict engineering guidelines to ensure code quality, maintainability, and security for Next.js projects.  
All contributors should adhere to the following rules, which are enforced throughout the codebase.

---

## 2. TypeScript Discipline & Types Organization

- **All type definitions must reside in the appropriate types directories:**
  - **Shared types** (used across frontend and backend) should be in [`shared/types/`](mdc:shared/types)
  - Application-wide types should be in [`types/`](mdc:types)
  - Component or library-specific types should be in [`lib/types/`](mdc:lib/types)
  - Do not define types or interfaces directly in component, helper, or utility files.
- **Prefer `type` over `interface`** for consistency across the codebase.
- **No `any` allowed** - Create appropriate type definitions for all variables and functions.
- **Always check dependencies before deleting types or functions** - Use `grep_search` to verify usage before removal.
- **Avoid type duplication** - Import and re-export from shared types instead of redefining.
- Always import types from their respective type files - avoid redefining types.
- Ensure type exports are properly named and documented.
- **Handle type conflicts properly** - When accessing properties that may not exist in a type, use proper fallback logic (e.g., `property || fallbackValue`).

**Shared Types Structure:**
- `shared/types/database.ts` - Database-related types
- `shared/types/entities.ts` - Core entity types
- `shared/types/api.ts` - API request/response types
- `shared/types/common.ts` - Common utility types
- `shared/types/auth.ts` - Authentication types
- `shared/types/analytics.ts` - Analytics and dashboard types
- `shared/types/index.ts` - Central export point for all shared types

**References:**  
- `shared/types/` - Shared types across frontend and backend
- `types/` - Application-wide types
- `lib/types/` - Component or library-specific types

---

## 3. ESLint & Code Style

- **Never ignore ESLint rule violations.**
- Address all ESLint warnings and errors immediately.
- Run `pnpm lint` regularly to catch and fix style issues.
- Follow the established code style in the existing files for consistency.
- Use ESLint's auto-fix feature when possible: `pnpm lint --fix`.

**Reference:**  
- `eslint.config.mjs` - ESLint configuration

---

## 4. File Organization & Separation of Concerns

- **Keep all `page.tsx` and component files lean.**
  - Offload complex logic into helper functions and utilities.
- **API-related logic should reside in [`lib/helpers/`](mdc:lib/helpers) or specific feature directories.**
- **Shared utilities should reside in [`lib/utils/`](mdc:lib/utils) or [`utils/`](mdc:utils).**
- **Context providers should be in [`lib/contexts/`](mdc:lib/contexts) or [`context/`](mdc:context).**
- **Feature-specific code should be organized within their related directories** in `lib/` (e.g., `lib/chat/`, `lib/profile/`).
- Do not mix API logic with UI or utility logic.
- **Create reusable UI components** in `components/ui/` for common patterns (e.g., `FinancialMetricsCards`). This folder is commonly for library components so only create components if the library doesn't have.

**Folder Structure Best Practices:**
- **Shared code** → `shared/` (types, utilities, constants)
- **Frontend-specific** → `lib/` (helpers, utils, contexts, types)
- **Backend-specific** → `app/api/` (routes, models, helpers)
- **Components** → `components/` (UI components, pages)
- **UI Components** → `components/ui/` (reusable UI components)
- **Feature modules** → `lib/[feature]/` (e.g., `lib/chat/`, `lib/auth/`)

**References:**  
- `shared/` - Shared code (types, utilities, constants)
- `lib/helpers/` - API-related logic and helpers
- `lib/utils/` - Shared utilities
- `components/` - UI components and pages
- `components/ui/` - Reusable UI components
- `app/` - Next.js app directory structure

---

## 5. Comments & Documentation

- **Remove redundant comments** that simply restate the meaning of well-named code.
- In helper and utility files:
  - Every function should have a concise block comment describing:
    - Its purpose
    - Its parameters
    - Its return value
- Document complex business logic with clear explanations.
- Update comments when code changes.

---

## 6. Security & Authentication/Authorization

- **Implement secure authentication practices** using JWT tokens with `jose` library.
- **Follow OWASP standards** to safeguard code from vulnerabilities.
- Never expose sensitive information (API keys, tokens) in client-side code.
- Always validate and sanitize user input, especially in form submissions.
- Use middleware for route protection where necessary.
- Store JWT tokens in secure HTTP-only cookies with proper expiration.

**References:**  
- `middleware.ts` - Next.js middleware for route protection
- `app/api/lib/helpers/auth.ts` - Authentication helpers

---

## 7. Component Structure & State Management

- Use appropriate state management solutions based on scope:
  - React's `useState` and `useReducer` for local component state
  - Context API for shared state across component tree
  - Zustand for application-wide state management
- Keep components focused on a single responsibility.
- Extract reusable UI elements into separate components.
- Implement proper error handling in components, especially for async operations.
- **Create reusable components** for common UI patterns (e.g., financial metrics cards, data tables).
- **Use proper prop types** with clear interfaces for component props.
- **Implement loading states** for async operations with skeleton loaders.
- **Handle data aggregation** in components when displaying totals from multiple data sources.

---

## 7.1. Loading States & Skeleton Loaders - CRITICAL REQUIREMENTS

- **MANDATORY: Every page and component with async data MUST use specific skeleton loaders**
- **NEVER use generic loading states** like "Loading...", "Loading Data", or generic spinners
- **EVERY skeleton loader MUST exactly match the layout and structure of the actual content**
- **Skeleton loaders MUST be page/component-specific** - no generic reusable skeletons for different content types

### **Skeleton Loader Requirements:**

#### **1. Content-Specific Skeletons:**
- **Each page must have its own skeleton** that matches the exact layout of the real content
- **Each tab/section must have its own skeleton** that represents the specific content structure
- **Skeleton must include all visual elements**: headers, cards, tables, buttons, forms, charts, etc.
- **Skeleton must match responsive behavior**: desktop table view, mobile card view, etc.

#### **2. Visual Accuracy:**
- **Exact dimensions and spacing** as the real content
- **Proper visual hierarchy** with headers, descriptions, and content areas
- **All interactive elements** represented (buttons, inputs, dropdowns, etc.)
- **Status indicators** included where appropriate (online/offline dots, badges, etc.)
- **Pagination controls** represented in skeleton form

#### **3. Implementation Standards:**
- **Use Shadcn Skeleton component** for all skeleton elements
- **Create dedicated skeleton files** in `components/ui/skeletons/`
- **Name skeletons specifically**: `PageNameSkeleton`, `TabNameSkeleton`, `SectionNameSkeleton`
- **Import and use specific skeletons** in each component
- **NO generic `MainContentSkeleton` or similar** - each must be content-specific

#### **4. File Organization:**
- **Skeleton files**: `components/ui/skeletons/[PageName]Skeletons.tsx`
- **Export specific skeletons**: `export const PageNameSkeleton = () => (...)` 
- **Import in components**: `import { PageNameSkeleton } from "@/components/ui/skeletons/[PageName]Skeletons"`
- **Use in loading states**: `{loading ? <PageNameSkeleton /> : <ActualContent />}`

#### **5. Examples of PROPER Implementation:**
```typescript
// ✅ CORRECT - Specific skeleton for Machines Overview tab
export const MachinesOverviewSkeleton = () => (
  <div className="space-y-6">
    {/* Machine Statistics Cards */}
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
      {Array.from({ length: 4 }).map((_, i) => (
        <Card key={i} className="min-h-[120px]">
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div className="space-y-2">
                <Skeleton className="h-4 w-20" />
                <Skeleton className="h-8 w-16" />
                <div className="flex items-center gap-2">
                  <Skeleton className="h-4 w-4" />
                  <Skeleton className="h-4 w-12" />
                </div>
              </div>
              <Skeleton className="h-12 w-12 rounded-full" />
            </div>
          </CardContent>
        </Card>
      ))}
    </div>
    {/* Filters, Table, Pagination - all matching real content */}
  </div>
);

// ❌ WRONG - Generic skeleton
export const GenericSkeleton = () => (
  <div className="animate-pulse">
    <div className="h-4 bg-gray-200 rounded w-3/4 mb-2"></div>
    <div className="h-4 bg-gray-200 rounded w-1/2"></div>
  </div>
);
```

#### **6. Enforcement Rules:**
- **Code reviews MUST verify** skeleton loaders match content layout
- **NO text-based loading states** allowed ("Loading...", "Loading Data", etc.)
- **NO generic spinners** for content areas
- **ALL async operations** must show appropriate skeleton
- **Skeleton must be visible** during data fetching, not hidden behind sidebars

#### **7. Common Violations to AVOID:**
- ❌ Using `MainContentSkeleton` for different content types
- ❌ Generic "Loading..." text instead of skeleton
- ❌ Spinner in content area instead of skeleton
- ❌ Skeleton that doesn't match actual content layout
- ❌ Skeleton hidden behind sidebar or other elements
- ❌ Same skeleton used for different pages/tabs

**References:**
- `components/ui/skeletons/` - All skeleton components
- `components/ui/skeletons/ReportsSkeletons.tsx` - Example of proper implementation

---

## 8. Performance Optimization

- Implement proper code-splitting and lazy loading for pages and large components.
- Optimize images using Next.js Image component.
- Minimize unnecessary re-renders with memoization techniques.
- Use efficient data fetching patterns to prevent waterfalls.
- Implement proper caching strategies for API responses.
- **Use debouncing for search inputs** to prevent excessive API calls.
- **Implement proper cleanup** for event listeners, timeouts, and subscriptions.
- **Memoize expensive computations** and callback functions to prevent unnecessary re-renders.
- **Calculate derived data efficiently** - Use `useMemo` for expensive calculations like financial totals.
- **Optimize data aggregation** - Calculate totals once and reuse them across components.

---

## 9. Testing Best Practices

- Focus on manual testing of critical user flows during development.
- Implement proper error handling and logging for debugging.
- Use TypeScript for compile-time error catching.
- Use the Go-based MongoDB query tool in `test/` directory for database validation and testing.

---

## 10. Accessibility & Internationalization

- Ensure all components are accessible with proper ARIA attributes.
- Use semantic HTML elements.
- Support keyboard navigation.
- Prepare for internationalization by avoiding hardcoded strings where possible.

---

## 11. Code Cleanup & Dependency Management

- **Always check dependencies before deleting code:**
  - Use `grep_search` to find all usages of a type, function, or variable
  - Check both import statements and direct usage
  - Verify no code depends on the item before removal
- **Handle type conflicts properly:**
  - When importing types from multiple sources, ensure no naming conflicts
  - Use explicit imports or aliases to resolve conflicts
  - Prefer shared types over local duplicates
- **Clean up unused imports and exports:**
  - Remove unused imports to reduce bundle size
  - Update index files when removing exports
  - Verify all imports are still valid after changes
- **Follow the dependency chain:**
  - When removing a type/function, check what imports it
  - Update or remove dependent code accordingly
  - Ensure the build still passes after cleanup

---

## 12. Frontend-Backend Type Consistency

- **Before creating or modifying types that represent backend data:**
  - **Trace the data flow** from API endpoint to frontend usage
  - **Check the original API source** in `app/api/` routes to understand the data structure
  - **Verify database schema** if the type represents database entities
  - **Ensure shared types match** the actual API response structure
- **Type synchronization workflow:**
  1. **Identify the API endpoint** that provides the data
  2. **Examine the response structure** in the route handler
  3. **Check database models** if applicable (MongoDB schemas, Prisma models)
  4. **Update shared types** to match the actual data structure
  5. **Verify frontend usage** aligns with the updated types
- **Common patterns to check:**
  - **API response transformations** (e.g., `_id` to `id`, date formatting)
  - **Optional vs required fields** based on API behavior
  - **Nested object structures** and their relationships
  - **Array types** and their element structures
  - **Calculated fields** that may not exist in the original data structure
- **Validation approach:**
  - **Use TypeScript strict mode** to catch type mismatches
  - **Test API endpoints** to verify response structure
  - **Check runtime data** in browser dev tools
  - **Validate against database schema** for entity types
  - **Handle missing properties gracefully** with fallback values and proper type guards

**References:**
- `app/api/` - API route handlers
- `shared/types/` - Shared type definitions
- `app/api/lib/models/` - Database models

---

**Summary:**  
Persistence: Keep going until the job is completely solved before ending your turn.
Plan than reflect: Plan thoroughly before every tool call then reflect on the outcome after
This project enforces strict discipline in type safety, code style, modularity, security, and build integrity.  
Use your tools don't guess: If you're unsure about code or files, open them - do not hallucinate.
**Always check dependencies before deleting code** - Use grep_search to verify usage patterns.
**Prefer shared types over duplicates** - Maintain single source of truth for types.
**Trace API data flow** - Check original backend source before creating/modifying types.
**Handle type conflicts gracefully** - Use proper fallback logic for missing properties.
**Create reusable components** - Extract common UI patterns into reusable components.

All contributors must follow these rules to ensure a robust, maintainable, and secure codebase.